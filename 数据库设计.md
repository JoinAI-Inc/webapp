1. ER 图核心概念模型
- Users: 用户基础表。
- Apps: 核心资产，Web 应用定义。
- Pricing Plans: 售卖单元（商品），定义了价格、周期、包含哪些 App。
- Orders: 交易流水，记录支付状态。
- Entitlements: 权益/授权书，这是用户访问应用的“门票”。

2. 详细表结构设计
2.1 用户管理模块 (User Management)
-- 用户表
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL, -- 或对接 SSO
    full_name VARCHAR(100),
    
    -- 状态管理
    status ENUM('ACTIVE', 'LOCKED') DEFAULT 'ACTIVE' COMMENT '用户状态',
    
    -- Stripe 映射 (方便后续续费扣款)
    stripe_customer_id VARCHAR(100),
    
    -- 统计字段 (可选择非规范化存储，或通过定时任务计算)
    total_spend_amount DECIMAL(10, 2) DEFAULT 0.00 COMMENT '总消费金额',
    total_order_count INT DEFAULT 0 COMMENT '订单数',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
2.2 应用管理模块 (App Management)
-- 应用表
CREATE TABLE apps (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    app_key VARCHAR(64) NOT NULL UNIQUE COMMENT '应用唯一标识，用于API调用',
    name VARCHAR(100) NOT NULL,
    description TEXT,
    access_url VARCHAR(512) NOT NULL COMMENT 'Web应用访问地址',
    
    -- 应用状态
    status ENUM('DRAFT', 'PUBLISHED', 'ARCHIVED') DEFAULT 'DRAFT',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
2.3 收费与计费模块 (Pricing & Billing)
这里采用“多对多”关系，因为一个收费计划可能包含多个应用（打包卖），一个应用也可能出现在多个收费计划中（单独卖或组合卖）。
-- 收费项目（商品）主表
CREATE TABLE pricing_plans (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL COMMENT '套餐名称，如：高级会员月卡',
    
    -- 收费类型
    plan_type ENUM('SUBSCRIPTION', 'ONE_TIME') NOT NULL,
    
    -- 应用范围：全局还是特定应用
    scope_type ENUM('GLOBAL', 'SPECIFIC_APP') NOT NULL COMMENT 'GLOBAL=全平台，SPECIFIC=指定应用',
    
    -- 价格信息
    price DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    
    -- 订阅周期 (仅 SUBSCRIPTION 有效)
    billing_interval ENUM('MONTH', 'QUARTER', 'YEAR') NULL,
    
    -- Stripe 映射
    stripe_product_id VARCHAR(100) COMMENT 'Stripe Product ID',
    stripe_price_id VARCHAR(100) COMMENT 'Stripe Price ID',
    
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否上架销售',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 收费项目与应用的关联表 (定义这个套餐里卖哪些 APP)-- 如果 scope_type = 'GLOBAL'，此表通常不记录数据或忽略CREATE TABLE pricing_plan_apps (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    pricing_plan_id BIGINT NOT NULL,
    app_id BIGINT NOT NULL,
    
    FOREIGN KEY (pricing_plan_id) REFERENCES pricing_plans(id),
    FOREIGN KEY (app_id) REFERENCES apps(id),
    
    UNIQUE KEY uk_plan_app (pricing_plan_id, app_id)
);
2.4 收入与订单模块 (Revenue & Orders)
-- 订单主表
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_no VARCHAR(64) NOT NULL UNIQUE COMMENT '系统内部订单号',
    user_id BIGINT NOT NULL,
    pricing_plan_id BIGINT NOT NULL, -- 购买了哪个套餐
    
    amount DECIMAL(10, 2) NOT NULL,
    currency VARCHAR(3) NOT NULL,
    
    -- 支付状态
    status ENUM('PENDING', 'PAID', 'FAILED', 'REFUNDED') DEFAULT 'PENDING',
    
    -- Stripe 支付数据
    stripe_session_id VARCHAR(100) COMMENT 'Checkout Session ID',
    stripe_payment_intent_id VARCHAR(100),
    
    paid_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (pricing_plan_id) REFERENCES pricing_plans(id)
);
2.5 授权与访问控制模块 (Entitlement & Access Control) - 核心设计
设计重点：
当订单支付成功（PAID）后，系统会根据 pricing_plan 的配置，生成一条或多条 entitlements 记录。
为什么不直接查订单？ 因为订单是历史记录，而 entitlements 代表当前有效的权益。如果未来你修改了套餐内容，老用户的权益不应受影响（快照原则）。
-- 用户授权记录表 (权益)
CREATE TABLE user_entitlements (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    
    -- 来源订单 (可溯源)
    source_order_id BIGINT, 
    
    -- 权益类型
    entitlement_type ENUM('SUBSCRIPTION', 'PERMANENT') NOT NULL,
    
    -- 权益范围 (快照自购买时的套餐配置)
    scope_type ENUM('GLOBAL', 'SPECIFIC_APP') NOT NULL,
    
    -- 有效期 (Subscription 必填，Permanent 为 NULL)
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expire_time TIMESTAMP NULL COMMENT '过期时间，过期即失效',
    
    -- 状态 (用于强制失效，如退款或违规)
    status ENUM('ACTIVE', 'EXPIRED', 'REVOKED') DEFAULT 'ACTIVE',
    
    -- 订阅关联 (用于处理续费回调更新 expire_time)
    stripe_subscription_id VARCHAR(100),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (source_order_id) REFERENCES orders(id),
    
    -- 索引优化：鉴权时最常用的查询
    INDEX idx_user_status_expire (user_id, status, expire_time)
);

-- 权益包含的具体应用 (快照)-- 如果 scope_type = 'GLOBAL'，此表可以为空，逻辑判断直接放行CREATE TABLE user_entitlement_apps (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    entitlement_id BIGINT NOT NULL,
    app_id BIGINT NOT NULL,
    
    FOREIGN KEY (entitlement_id) REFERENCES user_entitlements(id),
    FOREIGN KEY (app_id) REFERENCES apps(id),
    
    UNIQUE KEY uk_entitlement_app (entitlement_id, app_id)
);

3. 关键业务流程的 SQL 逻辑映射
3.1 场景：用户访问应用 App-A 时的鉴权逻辑 (5.3)
这是系统最高频的操作，SQL 必须高效。
逻辑：查找该用户是否有 有效的、覆盖 App-A 或 全局 的权益。
SELECT count(1) 
FROM user_entitlements ue
LEFT JOIN user_entitlement_apps uea ON ue.id = uea.entitlement_id
WHERE 
    ue.user_id = ? -- 当前用户IDAND ue.status = 'ACTIVE' -- 状态必须激活AND (ue.expire_time IS NULL OR ue.expire_time > NOW()) -- 未过期或是永久AND (
        ue.scope_type = 'GLOBAL' -- 或者是全平台会员OR 
        uea.app_id = ? -- 或者是包含当前 App-A 的 ID
    )
LIMIT 1;
如果返回结果 > 0，则允许访问。
3.2 场景：Stripe 订阅自动续费回调 (Webhook)
当 Stripe 发送 invoice.payment_succeeded 事件时：
1. 根据 Stripe 的 subscription_id 找到 user_entitlements 表中的记录。
2. 更新 expire_time (例如延长一个月)。
UPDATE user_entitlements 
SET expire_time = DATE_ADD(expire_time, INTERVAL 1 MONTH), -- 实际需根据 Stripe 数据计算
    updated_at = NOW()
WHERE stripe_subscription_id = ?;
3.3 场景：计算平台总收入 (4.3.1)
-- 按天统计收入
SELECT 
    DATE(paid_at) as revenue_date, 
    SUM(amount) as total_revenue
FROM orders 
WHERE status = 'PAID'GROUP BY DATE(paid_at)
ORDER BY revenue_date DESC;

4. 补充说明与建议
1. 快照机制的重要性：
  - 在 user_entitlement_apps 表的设计中，我强调了它是“快照”。
  - 例子：假设“套餐A”包含了 App1 和 App2。用户购买后，生成了权益。后来管理员修改“套餐A”为包含 App1, App2 和 App3。
  - 设计选择：用户已购买的权益通常不应自动增加 App3（除非你是做类似 Netflix 的全平台订阅）。通过 user_entitlement_apps 记录明确的 app_id 列表，可以保证老用户的权益锁定，不会因为管理员修改 Pricing 配置而产生纠纷。
2. 用户状态锁定：
  - 在应用鉴权的 SQL 中，还需要额外检查 users.status = 'ACTIVE'。可以在应用代码层先查 Redis 缓存的用户状态，或者在 SQL Join 中加上 JOIN users u ON ... WHERE u.status = 'ACTIVE'。
3. 索引优化：
  - apps.app_key: 用于 API 路由解析。
  - user_entitlements.user_id + status: 高频鉴权。
  - orders.order_no 和 orders.stripe_session_id: 用于回调处理和客服查询。